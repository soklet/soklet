## Soklet

#### What Is It?

Minimalist infrastructure for Java webapps and microservices.

#### Design Goals

* Single focus, unopinionated
* No external servlet container required
* Fast startup
* No 3rd party dependencies - uses only standard JDK APIs
* Extensible - applications can easily hook/override core functionality vi DI
* Self-contained deployment (single zip file)
* Static resource filename hashing for efficient HTTP caching and versioning
* Java 8+, Servlet 3.1+

#### Design Non-Goals

* Dictation of what libraries and versions to use (GSON vs. Jackson, Mustache vs. Velocity, etc.)
* Baked-in authentication and authorization
* Database support (you can bring your own with [Pyranid](http://www.pyranid.com))

#### License

[Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0)

#### Maven Installation

```xml
<dependency>
  <groupId>com.soklet</groupId>
  <artifactId>soklet</artifactId>
  <version>1.0.3</version>
</dependency>
```

#### Direct Download

If you don't use Maven, you can drop [soklet-1.0.3.jar](http://central.maven.org/maven2/com/soklet/soklet/1.0.3/soklet-1.0.3.jar) directly into your project.  You'll also need [javax.inject-1.jar](http://central.maven.org/maven2/javax/inject/javax.inject/1/javax.inject-1.jar) and [javax.servlet-api-3.1.0.jar](http://central.maven.org/maven2/javax/servlet/javax.servlet-api/3.1.0/javax.servlet-api-3.1.0.jar) as dependencies.

## Bootstrap Your App

TODO - discussion

```
$ git clone https://github.com/soklet/soklet.git
$ cd soklet
$ mvn -q exec:exec
```

## App Startup

Soklet applications are designed to launch via ```public static void main()``` like a regular Java application.  You do not have to worry about environment and server setup, deployment headaches, and tricky debugging.

```java
// Assumes you're using Guice as your DI framework via soklet-guice
public static void main(String[] args) throws Exception {
  Injector injector = Guice.createInjector(Modules.override(new SokletModule()).with(new AppModule()));
  Server server = injector.getInstance(Server.class);
  server.start();
  System.in.read(); // Wait for keypress
  server.stop();
}

class AppModule extends AbstractModule {
  @Provides
  @Singleton
  public Server provideServer(InstanceProvider instanceProvider) {
    // Assumes you're using Jetty as your server via soklet-jetty.
    // If you prefer Tomcat, soklet-tomcat is an alternative
    return JettyServer.forInstanceProvider(instanceProvider).port(8080).build();
  }

  // You'll likely want to override Soklet's defaults.
  // Dependency injection makes this easy.
  //
  // For example, if your API endpoints should return JSON generated by Jackson,
  // use Guice to provide your own ApiResponseWriter implementation.
  @Provides
  @Singleton
  public ApiResponseWriter provideApiResponseWriter() {
    return MyJacksonApiResponseWriter();
  }
}
```

## Resource Methods

Soklet's main job is mapping Java methods to URLs.  We refer to these methods as  _resource methods_.

Resource methods may return any type, such as ```String``` or ```UUID```, but normally you'll return special types like ```PageResponse``` and ```ApiResponse```.

#### Example Code

```java
// Any class containing URL-resource methods must have the @Resource annotation applied.
// This is a performance optimization for fast startup time. Soklet uses an annotation processor
// at compile time to create a lookup table which avoids runtime reflection
@Resource
public class HelloResource {
  // You may return arbitrary types - the object's toString() value is written
  // to the response as text/plain;charset=UTF-8
  @GET("/hello")
  public String hello() {
    return "Hello, world!";
  }  

  // Response body looks like you would expect: 100.25
  @GET("/hello-big-decimal")
  public Object helloBigDecimal() {
    return new BigDecimal(100.25);
  }

  // Path parameters and query parameters are easy to access via annotations.
  // By default, reflection is used to determine their names,
  // but you can override by supplying an explicit name.
  //
  // If a parameter is not required, you must wrap it in an Optional.
  // Path parameters are implicitly required as they are part of the URL itself.
  //
  // If a value cannot be converted to the declared type (for example, t=abc below)
  // or is required but missing, an appropriate exception is thrown and a 400 response is returned.
  //
  // Value conversion strategies are customizable - Soklet supports many standard Java types
  // out of the box, but you can add more or override as needed via a custom ValueConverterRegistry.
  // See the "Customization" section for details
  //
  // Example URL: /hello/everyone?t=10
  @GET("/hello/{target}")
  public void hello(@PathParameter String target, @QueryParameter("t") Optional<Integer> times) {
    if (times.isPresent())
      out.println(format("Saying %d hellos to %s!", times.get(), target));
    else
      out.println(format("Not saying hello to %s!", target));
  }

  // Soklet has the concept of a PageResponse, which associates a logical page name with an optional
  // map of data to be merged into it and written to the HTTP response.
  //
  // Each application will do it differently - Velocity, Freemarker, Mustache, etc.
  // You just need to provide Soklet with a PageResponseWriter implementation.
  //
  // Example URL: /hello-there?name=Steve
  @GET("/hello-there")
  public PageResponse helloTherePage(@QueryParameter String name) {
    return new PageResponse("hello-there", new HashMap<String, Object>() {
      {
        put("name", name);
      }
    });
  }  

  // ApiResponse is similar to PageResponse, except that it accepts an arbitrary Object
  // intended to be written to the HTTP response.
  //
  // Each application will do it differently - Jackson, GSON, XML, Protocol Buffers, etc.
  // You just need to provide Soklet with an ApiResponseWriter implementation.
  //
  // Example URL: /api/hello-there?name=Steve
  @GET("/api/hello-there")
  public ApiResponse helloThereApi(@QueryParameter String name) {
    return new ApiResponse(new HashMap<String, Object>() {
      {
        put("name", name);
      }
    });
  }

  @POST("/api/hello")
  public ApiResponse createHello(String requestBody) {
    // TODO
  }

  // BinaryResponse allows you to specify arbitrary data and content type.
  // Useful for PDFs, CSVs, edge cases
  @GET("/hello.pdf")
  public BinaryResponse helloPdf() {
    InputStream pdfInputStream = generateMyPdf();
    return new BinaryResponse("application/pdf", pdfInputStream);
  }

  // RedirectResponse performs temporary and permanent redirects.
  //
  // Example URL: /redirect?temporary=true
  @GET("/redirect")
  public RedirectResponse redirect(@QueryParameter boolean temporary) {
    return new RedirectResponse("http://google.com",
      temporary ? RedirectResponse.Type.TEMPORARY : RedirectResponse.Type.PERMANENT);
  }  

  // Methods with a void return type are 204s
  @GET("/no-response")
  public void noResponse() {
    out.println("I'll return a 204");
  }

  // Methods that return nulls are 204s as well
  @GET("/another-no-response")
  public Object anotherNoResponse() {
    out.println("I'll also return a 204");
    return null;
  }  

  // The same resource method can handle multiple URLs
  @GET("/twins")
  @GET("/triplets")
  @POST("/quadruplets")
  public String multiples() {
    return "Multiples work as expected";
  }
}
```

#### Resource Method Return Types

There are 5 standard resource method return types provided by Soklet.

* ```ApiResponse``` Holds an arbitrary object that
* ```AsyncResponse``` Signifies to Soklet that no response should be written and you plan to use Servlet 3.1 nonblocking I/O to handle it yourself.  Useful if you have an expensive computation to perform and don't want to tie up a request thread
* ```BinaryResponse``` Designed for writing arbitrary content to the response, e.g. streaming a PDF
* ```PageResponse```
* ```RedirectResponse``` Performs standard 301 and 302 redirects

Returning ```void``` or ```null``` will result in a ```204``` with an empty response body.

Returning different types like ```UUID``` or ```Double``` will invoke Soklet's default behavior of writing their ```toString()``` value to the response with content type ```text/plain;charset=UTF-8```.

#### Response Writers

You might implement a [Mustache.java](https://github.com/spullara/mustache.java) ```PageResponseWriter``` like this:

```java
class MustachePageResponseWriter implements PageResponseWriter {
  private final MustacheFactory mustacheFactory;

  MustachePageResponseWriter() {
    // Mustache templates live in the "pages" directory
    this.mustacheFactory = new DefaultMustacheFactory(Paths.get("pages").toFile());
  }

  @Override
  public void writeResponse(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,
      Optional<PageResponse> response, Optional<Route> route, Optional<Exception> exception) throws IOException {
    // Make sure our content type is correct
    httpServletResponse.setContentType("text/html;charset=UTF-8");

    // Keep track of what to write to the response
    String name = null;
    Map<String, Object> model = null;

    if (response.isPresent()) {
      // Happy path - resource method completed successfully and returned a value
      name = response.get().name();
      model = response.get().model().orElse(null);
    } else {
      // There was a problem - render an error page
      name = "error";
      model = new HashMap<String, Object>() {
        {
          put("status", httpServletResponse.getStatus());
        }
      };
    }

    // Create a mustache instance and write the merged output to the response
    Mustache mustache = this.mustacheFactory.compile(format("%s.html", name));

    try (OutputStream outputStream = httpServletResponse.getOutputStream()) {
      mustache.execute(new OutputStreamWriter(outputStream, UTF_8), model).flush();
    }
  }  
}
```

You might implement a [Jackson](https://github.com/FasterXML/jackson) ```ApiResponseWriter``` like this:

```java
class JacksonApiResponseWriter implements ApiResponseWriter {
  private final ObjectMapper objectMapper = new ObjectMapper();

  @Override
  public void writeResponse(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,
      Optional<ApiResponse> response, Optional<Route> route, Optional<Exception> exception) throws IOException {
    // Make sure our content type is correct
    httpServletResponse.setContentType("application/json;charset=UTF-8");

    // Keep track of what to write to the response
    Map<String, Object> model = null;

    if (response.isPresent()) {
      // Happy path - resource method completed successfully and returned a value
      model = response.get().model().orElse(null);
    } else {
      // There was a problem - render an error response
      model = new HashMap<String, Object>() {
        {
          put("status", httpServletResponse.getStatus());
          put("message", "An error occurred!");
        }
      };
    }

    // Write JSON to the response
    try (OutputStream outputStream = httpServletResponse.getOutputStream()) {
      objectWriter.writeValue(outputStream, model);
    }
  }  
}
```

## Customization

Coming soon

## Deployment

Coming soon

## FAQ
